//! Banking Example: Virtual actors + static endpoints coexisting.
//!
//! This example demonstrates the virtual actor networking layer running
//! alongside static RPC interfaces on the same transport.
//!
//! # What It Shows
//!
//! - A static `PingPong` interface (existing pattern, proves coexistence)
//! - A virtual `BankAccount` actor with `deposit`, `withdraw`, `get_balance`
//! - Hand-written actor state and method dispatch (no macro yet)
//! - Single process, local delivery, single transport
//!
//! # Architecture
//!
//! ```text
//! EndpointMap:
//!   UID(0x5049_4E47, 1) → PingPong::ping RequestStream   (static, index 1)
//!   UID(0xBA4E_4B00, 0) → BankAccount handler             (virtual, all methods)
//! ```
//!
//! Both the static endpoint and virtual actor handler live on the same
//! transport and `EndpointMap`. The `select!` loop services both.

use std::collections::HashMap;
use std::rc::Rc;

use moonpool::actors::{
    ActorDirectory, ActorId, ActorMessage, ActorResponse, ActorRouter, ActorType,
    InMemoryDirectory, LocalPlacement,
};
use moonpool::{
    Endpoint, JsonCodec, MessageCodec, NetTransportBuilder, NetworkAddress, Providers,
    RequestStream, RpcError, UID, interface,
};
use serde::{Deserialize, Serialize};

// ============================================================================
// Static Interface: PingPong (proves coexistence)
// ============================================================================

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
struct PingRequest {
    seq: u32,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
struct PingResponse {
    seq: u32,
}

#[interface(id = 0x5049_4E47)]
trait PingPong {
    async fn ping(&self, req: PingRequest) -> Result<PingResponse, RpcError>;
}

// ============================================================================
// Virtual Actor: BankAccount
// ============================================================================

/// Actor state for a single bank account instance.
struct BankAccountState {
    balance: i64,
}

/// Deposit request.
#[derive(Debug, Clone, Serialize, Deserialize)]
struct DepositRequest {
    amount: i64,
}

/// Withdraw request.
#[derive(Debug, Clone, Serialize, Deserialize)]
struct WithdrawRequest {
    amount: i64,
}

/// Get balance request.
#[derive(Debug, Clone, Serialize, Deserialize)]
struct GetBalanceRequest {}

/// Balance response (shared by all methods).
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
struct BalanceResponse {
    balance: i64,
}

/// Actor type constant (would be generated by a future macro).
const BANK_ACCOUNT_TYPE: ActorType = ActorType(0xBA4E_4B00);

/// Method discriminants (would be generated by a future macro).
mod bank_methods {
    pub const DEPOSIT: u32 = 1;
    pub const WITHDRAW: u32 = 2;
    pub const GET_BALANCE: u32 = 3;
}

// ============================================================================
// Server: handles both static ping and virtual bank account
// ============================================================================

/// Run the server loop: services both static and virtual actor endpoints.
///
/// This function runs until the shutdown signal is received.
async fn run_server<P: Providers>(
    transport: Rc<moonpool::NetTransport<P>>,
    ping_server: PingPongServer<JsonCodec>,
    bank_receiver: RequestStream<ActorMessage, JsonCodec>,
) {
    let codec = JsonCodec;
    let mut actors: HashMap<String, BankAccountState> = HashMap::new();

    // Process a fixed number of messages then exit.
    // In a real system this would be an infinite loop.
    let mut messages_processed = 0;
    let expected_messages = 8; // 5 bank requests + 1 ping + 2 extra

    while messages_processed < expected_messages {
        tokio::select! {
            // Static endpoint: PingPong
            Some((req, reply)) = ping_server.ping.recv_with_transport::<_, PingResponse>(&transport) => {
                println!("  [server] PING seq={}", req.seq);
                reply.send(PingResponse { seq: req.seq });
                messages_processed += 1;
            }

            // Virtual actor endpoint: BankAccount (all instances, all methods)
            Some((actor_msg, reply)) = bank_receiver.recv_with_transport::<_, ActorResponse>(&transport) => {
                // Find or create actor by identity (Orleans activation pattern)
                let actor = actors
                    .entry(actor_msg.target.identity.clone())
                    .or_insert_with(|| {
                        println!("  [server] Activating BankAccount '{}'", actor_msg.target.identity);
                        BankAccountState { balance: 0 }
                    });

                // Method dispatch
                let response_body = match actor_msg.method {
                    bank_methods::DEPOSIT => {
                        let req: DepositRequest = codec.decode(&actor_msg.body)
                            .expect("decode deposit request");
                        actor.balance += req.amount;
                        println!("  [server] DEPOSIT '{}' +{} → balance={}", actor_msg.target.identity, req.amount, actor.balance);
                        codec.encode(&BalanceResponse { balance: actor.balance })
                            .expect("encode response")
                    }
                    bank_methods::WITHDRAW => {
                        let req: WithdrawRequest = codec.decode(&actor_msg.body)
                            .expect("decode withdraw request");
                        actor.balance -= req.amount;
                        println!("  [server] WITHDRAW '{}' -{} → balance={}", actor_msg.target.identity, req.amount, actor.balance);
                        codec.encode(&BalanceResponse { balance: actor.balance })
                            .expect("encode response")
                    }
                    bank_methods::GET_BALANCE => {
                        println!("  [server] GET_BALANCE '{}' → balance={}", actor_msg.target.identity, actor.balance);
                        codec.encode(&BalanceResponse { balance: actor.balance })
                            .expect("encode response")
                    }
                    other => {
                        panic!("unknown method: {}", other);
                    }
                };

                reply.send(ActorResponse { body: response_body });
                messages_processed += 1;
            }
        }
    }
}

// ============================================================================
// Client: uses ActorRouter for virtual actors, bound client for static
// ============================================================================

async fn run_client<P: Providers>(
    transport: Rc<moonpool::NetTransport<P>>,
    directory: Rc<dyn ActorDirectory>,
    local_addr: NetworkAddress,
) -> Result<(), Box<dyn std::error::Error>> {
    // Set up actor router for virtual actor calls
    let local_endpoint = Endpoint::new(local_addr.clone(), UID::new(BANK_ACCOUNT_TYPE.0, 0));
    let placement: Rc<dyn moonpool::actors::PlacementStrategy> =
        Rc::new(LocalPlacement::new(local_endpoint));
    let router = ActorRouter::new(transport.clone(), directory, placement, JsonCodec);

    // Set up static PingPong client
    let ping_client = PingPongClient::new(local_addr).bind(transport.clone(), JsonCodec);

    println!("\n--- Virtual Actor: BankAccount ---\n");

    // Deposit to alice
    let resp: BalanceResponse = router
        .send_actor_request(
            &ActorId {
                actor_type: BANK_ACCOUNT_TYPE,
                identity: "alice".into(),
            },
            bank_methods::DEPOSIT,
            &DepositRequest { amount: 100 },
        )
        .await?;
    println!("  [client] Alice balance after deposit: {}", resp.balance);
    assert_eq!(resp.balance, 100);

    // Deposit to bob
    let resp: BalanceResponse = router
        .send_actor_request(
            &ActorId {
                actor_type: BANK_ACCOUNT_TYPE,
                identity: "bob".into(),
            },
            bank_methods::DEPOSIT,
            &DepositRequest { amount: 50 },
        )
        .await?;
    println!("  [client] Bob balance after deposit: {}", resp.balance);
    assert_eq!(resp.balance, 50);

    // Transfer: withdraw from alice, deposit to bob
    let resp: BalanceResponse = router
        .send_actor_request(
            &ActorId {
                actor_type: BANK_ACCOUNT_TYPE,
                identity: "alice".into(),
            },
            bank_methods::WITHDRAW,
            &WithdrawRequest { amount: 30 },
        )
        .await?;
    println!("  [client] Alice balance after withdraw: {}", resp.balance);
    assert_eq!(resp.balance, 70);

    let resp: BalanceResponse = router
        .send_actor_request(
            &ActorId {
                actor_type: BANK_ACCOUNT_TYPE,
                identity: "bob".into(),
            },
            bank_methods::DEPOSIT,
            &DepositRequest { amount: 30 },
        )
        .await?;
    println!(
        "  [client] Bob balance after transfer deposit: {}",
        resp.balance
    );
    assert_eq!(resp.balance, 80);

    // Check final balances
    let alice: BalanceResponse = router
        .send_actor_request(
            &ActorId {
                actor_type: BANK_ACCOUNT_TYPE,
                identity: "alice".into(),
            },
            bank_methods::GET_BALANCE,
            &GetBalanceRequest {},
        )
        .await?;
    assert_eq!(alice.balance, 70);
    println!("  [client] Alice final balance: {}", alice.balance);

    let bob: BalanceResponse = router
        .send_actor_request(
            &ActorId {
                actor_type: BANK_ACCOUNT_TYPE,
                identity: "bob".into(),
            },
            bank_methods::GET_BALANCE,
            &GetBalanceRequest {},
        )
        .await?;
    assert_eq!(bob.balance, 80);
    println!("  [client] Bob final balance: {}", bob.balance);

    println!("\n--- Static Interface: PingPong ---\n");

    // Also call static endpoint to prove coexistence
    let pong = ping_client.ping(PingRequest { seq: 42 }).await?;
    assert_eq!(pong.seq, 42);
    println!("  [client] Static ping seq=42 → pong seq={}", pong.seq);

    // One more ping
    let pong = ping_client.ping(PingRequest { seq: 99 }).await?;
    assert_eq!(pong.seq, 99);
    println!("  [client] Static ping seq=99 → pong seq={}", pong.seq);

    println!("\n--- Results ---\n");
    println!("  Virtual actors (BankAccount): alice=70, bob=80");
    println!("  Static endpoint (PingPong): 2 successful pings");
    println!("  Both coexist on the same transport!");

    Ok(())
}

// ============================================================================
// Main
// ============================================================================

fn main() {
    println!("=== Banking Example: Virtual Actors + Static Endpoints ===\n");

    let runtime = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build_local(Default::default())
        .expect("Failed to create Tokio LocalRuntime");

    runtime.block_on(async {
        if let Err(e) = run_example().await {
            eprintln!("Example error: {}", e);
            std::process::exit(1);
        }
    });
}

async fn run_example() -> Result<(), Box<dyn std::error::Error>> {
    // Shared local address for single-process local delivery
    let local_addr = NetworkAddress::parse("127.0.0.1:4700")?;

    // Build transport (no listening needed — all delivery is local)
    let providers = moonpool::TokioProviders::new();
    let transport = NetTransportBuilder::new(providers)
        .local_address(local_addr.clone())
        .build()?;

    // Register static PingPong handler (method index 1 after Phase 1 change)
    let ping_server = PingPongServer::init(&transport, JsonCodec);

    // Register virtual actor handler for BankAccount at token 0
    let bank_token = UID::new(BANK_ACCOUNT_TYPE.0, 0);
    let bank_receiver: RequestStream<ActorMessage, JsonCodec> =
        transport.register_handler(bank_token, JsonCodec);

    // Shared directory for actor location tracking
    let directory: Rc<dyn ActorDirectory> = Rc::new(InMemoryDirectory::new());

    // Spawn server loop as a background local task
    let server_transport = transport.clone();
    tokio::task::spawn_local(async move {
        run_server(server_transport, ping_server, bank_receiver).await;
    });

    // Run client (sends requests that are delivered locally)
    run_client(transport, directory, local_addr).await?;

    println!("\nExample completed successfully!");
    Ok(())
}
