//! Simulation tests for BankAccountActor across multiple topologies.
//!
//! These tests validate the actor system under deterministic chaos conditions
//! using moonpool-foundation's simulation framework.

use super::workload::{multi_node_workload, single_node_workload};
use moonpool_foundation::{SimulationBuilder, WorkloadTopology};

/// Test configuration for bank account simulations.
const SIMULATION_SEED: u64 = 42;
const BUGGIFY_ACTIVATION_PROB: f64 = 0.5;
const BUGGIFY_FIRING_PROB: f64 = 0.25;

/// Single-node simulation test (1x1 topology).
///
/// **Purpose**: Validate basic actor messaging on a single node.
///
/// **Topology**: 1 runtime, 1 actor
///
/// **Success Criteria**:
/// - Actor activates successfully
/// - Messages processed sequentially
/// - Final balance matches expected value
/// - No assertion failures
/// - 100% success rate over iterations
#[tokio::test]
async fn test_single_node_basic_operations() {
    // Initialize tracing for debugging
    let _ = tracing_subscriber::fmt()
        .with_test_writer()
        .with_max_level(tracing::Level::INFO)
        .try_init();

    tracing::info!("Starting test_single_node_basic_operations");

    // Create simulation builder
    let mut builder = SimulationBuilder::new()
        .with_seed(SIMULATION_SEED)
        .with_buggify(BUGGIFY_ACTIVATION_PROB, BUGGIFY_FIRING_PROB);

    // Add workload with 1x1 topology
    builder = builder.add_workload(
        "single_node_bank_account",
        WorkloadTopology::new(1, 1),
        single_node_workload,
    );

    // Build and run simulation
    let simulation = builder.build();
    let result = simulation.run().await;

    // Verify success
    match result {
        Ok(summary) => {
            tracing::info!("Simulation completed: {:?}", summary);
            assert_eq!(
                summary.failures, 0,
                "Simulation should have 0 failures, got {}",
                summary.failures
            );
        }
        Err(e) => {
            panic!("Simulation failed: {:?}", e);
        }
    }
}

/// Multi-node simulation test (2x2 topology).
///
/// **Purpose**: Validate cross-node messaging and directory routing.
///
/// **Topology**: 2 runtimes, 2 actors
///
/// **Success Criteria**:
/// - Actors activate on different nodes
/// - Cross-node messages route correctly
/// - Directory tracks locations accurately
/// - No message loss
/// - 100% success rate over iterations
#[tokio::test]
async fn test_multi_node_cross_node_messaging() {
    let _ = tracing_subscriber::fmt()
        .with_test_writer()
        .with_max_level(tracing::Level::INFO)
        .try_init();

    tracing::info!("Starting test_multi_node_cross_node_messaging");

    // Create simulation with 2x2 topology
    let mut builder = SimulationBuilder::new()
        .with_seed(SIMULATION_SEED)
        .with_buggify(BUGGIFY_ACTIVATION_PROB, BUGGIFY_FIRING_PROB);

    builder = builder.add_workload(
        "multi_node_bank_account",
        WorkloadTopology::new(2, 2),
        multi_node_workload,
    );

    let simulation = builder.build();
    let result = simulation.run().await;

    match result {
        Ok(summary) => {
            tracing::info!("Simulation completed: {:?}", summary);
            assert_eq!(
                summary.failures, 0,
                "Simulation should have 0 failures, got {}",
                summary.failures
            );
        }
        Err(e) => {
            panic!("Simulation failed: {:?}", e);
        }
    }
}

/// Stress test with default buggify (moderate chaos).
///
/// **Purpose**: Validate system under standard chaos conditions.
///
/// **Buggify**: 0.5 activation, 0.25 firing (default)
///
/// **Success Criteria**:
/// - All operations complete
/// - Banking invariant holds (sum of balances constant)
/// - No deadlocks
/// - All sometimes_assert! triggered
#[tokio::test]
#[ignore] // Enable for comprehensive testing (slow)
async fn test_stress_default_buggify() {
    let _ = tracing_subscriber::fmt()
        .with_test_writer()
        .with_max_level(tracing::Level::WARN)
        .try_init();

    let mut builder = SimulationBuilder::new()
        .with_seed(SIMULATION_SEED)
        .with_buggify(0.5, 0.25)
        .with_iterations(UntilAllSometimesReached::new(1000));

    builder = builder.add_workload(
        "stress_test",
        WorkloadTopology::new(2, 2),
        multi_node_workload,
    );

    let simulation = builder.build();
    let result = simulation.run().await;

    match result {
        Ok(summary) => {
            tracing::info!("Stress test completed: {:?}", summary);
            assert_eq!(summary.failures, 0, "All iterations should succeed");
            // TODO: Verify all sometimes_assert! were triggered
        }
        Err(e) => {
            panic!("Stress test failed: {:?}", e);
        }
    }
}

/// Aggressive chaos test (0.9/0.9 buggify).
///
/// **Purpose**: Extreme stress testing with maximum chaos injection.
///
/// **Buggify**: 0.9 activation, 0.9 firing (hostile)
///
/// **Success Criteria**:
/// - System remains stable under extreme chaos
/// - Eventual consistency achieved
/// - No permanent hangs or deadlocks
#[tokio::test]
#[ignore] // Enable for comprehensive testing (very slow)
async fn test_aggressive_buggify() {
    let _ = tracing_subscriber::fmt()
        .with_test_writer()
        .with_max_level(tracing::Level::ERROR)
        .try_init();

    let mut builder = SimulationBuilder::new()
        .with_seed(SIMULATION_SEED)
        .with_buggify(0.9, 0.9)
        .with_iterations(UntilAllSometimesReached::new(100));

    builder = builder.add_workload(
        "aggressive_chaos",
        WorkloadTopology::new(2, 2),
        multi_node_workload,
    );

    let simulation = builder.build();
    let result = simulation.run().await;

    match result {
        Ok(summary) => {
            tracing::info!("Aggressive chaos test completed: {:?}", summary);
            // Allow some failures under extreme chaos, but not too many
            assert!(
                summary.failures < summary.total_iterations / 10,
                "Failure rate should be < 10% under aggressive chaos"
            );
        }
        Err(e) => {
            panic!("Aggressive chaos test failed: {:?}", e);
        }
    }
}

/// Deterministic reproduction test.
///
/// **Purpose**: Verify same seed produces identical behavior.
///
/// **Success Criteria**:
/// - Two runs with same seed produce identical results
/// - All operation outcomes match
/// - Message order identical
#[tokio::test]
async fn test_deterministic_reproduction() {
    let _ = tracing_subscriber::fmt()
        .with_test_writer()
        .with_max_level(tracing::Level::INFO)
        .try_init();

    const FIXED_SEED: u64 = 12345;

    // First run
    let mut builder1 = SimulationBuilder::new()
        .with_seed(FIXED_SEED)
        .with_buggify(0.5, 0.25);

    builder1 = builder1.add_workload(
        "deterministic_test_1",
        WorkloadTopology::new(2, 2),
        multi_node_workload,
    );

    let simulation1 = builder1.build();
    let result1 = simulation1.run().await.expect("First run should succeed");

    // Second run with same seed
    let mut builder2 = SimulationBuilder::new()
        .with_seed(FIXED_SEED)
        .with_buggify(0.5, 0.25);

    builder2 = builder2.add_workload(
        "deterministic_test_2",
        WorkloadTopology::new(2, 2),
        multi_node_workload,
    );

    let simulation2 = builder2.build();
    let result2 = simulation2.run().await.expect("Second run should succeed");

    // Verify identical results
    assert_eq!(
        result1.total_iterations, result2.total_iterations,
        "Iteration counts should match"
    );
    assert_eq!(
        result1.failures, result2.failures,
        "Failure counts should match"
    );
    // TODO: Add more detailed comparison (message order, final state, etc.)
}
