//! Proc-macro for deriving FDB-style Interface pattern.
//!
//! This crate provides the `#[derive(Interface)]` macro that generates
//! `{Name}Server` and `{Name}Client` structs from an interface definition.
//!
//! # Example
//!
//! ```rust,ignore
//! use moonpool_transport_derive::Interface;
//!
//! #[derive(Interface)]
//! #[interface(id = 0xCA1C_0000)]
//! struct Calculator {
//!     add: (AddRequest, AddResponse),
//!     sub: (SubRequest, SubResponse),
//! }
//! ```
//!
//! This generates:
//! - `CalculatorServer<C>` with `RequestStream` fields and `init()` method
//! - `CalculatorClient` with method accessors returning `Endpoint`

use proc_macro::TokenStream;
use quote::{format_ident, quote};
use syn::{
    Attribute, Data, DeriveInput, Expr, ExprLit, Fields, GenericArgument, Ident, Lit, Meta,
    PathArguments, Type, parse_macro_input,
};

/// Derive macro for FDB-style Interface pattern.
///
/// Generates `{Name}Server` and `{Name}Client` structs from the interface definition.
///
/// # Attributes
///
/// - `#[interface(id = 0x...)]` - Required. Sets the interface ID (u64).
///
/// # Fields
///
/// Each field must be a tuple type `(RequestType, ResponseType)`.
/// Method indices are derived from field declaration order.
#[proc_macro_derive(Interface, attributes(interface))]
pub fn derive_interface(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    match derive_interface_impl(&input) {
        Ok(tokens) => tokens.into(),
        Err(err) => err.to_compile_error().into(),
    }
}

fn derive_interface_impl(input: &DeriveInput) -> syn::Result<proc_macro2::TokenStream> {
    // Extract interface ID from #[interface(id = 0x...)]
    let interface_id = extract_interface_id(&input.attrs)?;

    // Get struct name and fields
    let name = &input.ident;
    let server_name = format_ident!("{}Server", name);
    let client_name = format_ident!("{}Client", name);

    let fields = match &input.data {
        Data::Struct(data) => match &data.fields {
            Fields::Named(fields) => &fields.named,
            _ => {
                return Err(syn::Error::new_spanned(
                    input,
                    "Interface must have named fields",
                ));
            }
        },
        _ => return Err(syn::Error::new_spanned(input, "Interface must be a struct")),
    };

    // Parse fields: name: (RequestType, ResponseType)
    let mut method_infos: Vec<(u32, Ident, Type)> = Vec::new();
    for (index, field) in fields.iter().enumerate() {
        let field_name = field
            .ident
            .as_ref()
            .ok_or_else(|| syn::Error::new_spanned(field, "Field must have a name"))?;
        let req_type = parse_tuple_request_type(&field.ty)?;
        method_infos.push((index as u32, field_name.clone(), req_type));
    }

    let method_count = method_infos.len() as u32;

    // Generate server fields
    let server_fields = method_infos.iter().map(|(_, name, req_type)| {
        quote! { pub #name: moonpool_transport::RequestStream<#req_type, C> }
    });

    // Generate server init - clone codec for all but the last field
    let server_inits: Vec<_> = method_infos
        .iter()
        .enumerate()
        .map(|(i, (idx, name, _))| {
            let is_last = i == method_infos.len() - 1;
            if is_last {
                quote! {
                    let (#name, _) = transport.register_handler_at(Self::INTERFACE_ID, #idx as u64, codec);
                }
            } else {
                quote! {
                    let (#name, _) = transport.register_handler_at(Self::INTERFACE_ID, #idx as u64, codec.clone());
                }
            }
        })
        .collect();

    let server_field_names: Vec<_> = method_infos.iter().map(|(_, name, _)| name).collect();

    // Generate client methods
    // Use UID::new() to match server's register_handler_at which also uses UID::new()
    let client_methods = method_infos.iter().map(|(idx, name, _)| {
        quote! {
            /// Get endpoint for this method.
            pub fn #name(&self) -> moonpool_transport::Endpoint {
                moonpool_transport::Endpoint::new(
                    self.base.address.clone(),
                    moonpool_transport::UID::new(Self::INTERFACE_ID, #idx as u64)
                )
            }
        }
    });

    let expanded = quote! {
        /// Server-side interface with RequestStreams.
        ///
        /// Generated by `#[derive(Interface)]`.
        pub struct #server_name<C: moonpool_transport::MessageCodec> {
            #(#server_fields,)*
        }

        impl<C: moonpool_transport::MessageCodec + Clone> #server_name<C> {
            /// Interface identifier.
            pub const INTERFACE_ID: u64 = #interface_id;

            /// Number of methods in this interface.
            pub const METHOD_COUNT: u32 = #method_count;

            /// Initialize the server interface, registering all handlers.
            pub fn init<N, T, TP>(transport: &std::rc::Rc<moonpool_transport::NetTransport<N, T, TP>>, codec: C) -> Self
            where
                N: moonpool_transport::NetworkProvider + Clone + 'static,
                T: moonpool_transport::TimeProvider + Clone + 'static,
                TP: moonpool_transport::TaskProvider + Clone + 'static,
            {
                #(#server_inits)*
                Self { #(#server_field_names,)* }
            }
        }

        /// Client-side interface with Endpoints.
        ///
        /// Generated by `#[derive(Interface)]`.
        /// Only the base endpoint is serialized; method endpoints are derived.
        #[derive(Clone)]
        pub struct #client_name {
            base: moonpool_transport::Endpoint,
        }

        impl #client_name {
            /// Interface identifier.
            pub const INTERFACE_ID: u64 = #interface_id;

            /// Number of methods in this interface.
            pub const METHOD_COUNT: u32 = #method_count;

            /// Create a new client interface from a network address.
            pub fn new(address: moonpool_transport::NetworkAddress) -> Self {
                Self {
                    base: moonpool_transport::Endpoint::new(address, moonpool_transport::UID::new(Self::INTERFACE_ID, 0)),
                }
            }

            /// Create a client interface from an existing endpoint.
            pub fn from_endpoint(base: moonpool_transport::Endpoint) -> Self {
                Self { base }
            }

            /// Get the base endpoint (method 0).
            pub fn base_endpoint(&self) -> &moonpool_transport::Endpoint {
                &self.base
            }

            #(#client_methods)*
        }

        impl serde::Serialize for #client_name {
            fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
                self.base.serialize(serializer)
            }
        }

        impl<'de> serde::Deserialize<'de> for #client_name {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                let base = moonpool_transport::Endpoint::deserialize(deserializer)?;
                Ok(Self { base })
            }
        }
    };

    Ok(expanded)
}

/// Extract interface ID from `#[interface(id = 0x...)]` attribute.
fn extract_interface_id(attrs: &[Attribute]) -> syn::Result<u64> {
    for attr in attrs {
        if attr.path().is_ident("interface") {
            let meta = attr.meta.clone();
            if let Meta::List(list) = meta {
                let tokens = list.tokens;
                // Parse: id = 0x...
                let parsed: InterfaceAttr = syn::parse2(tokens)?;
                return Ok(parsed.id);
            }
        }
    }
    Err(syn::Error::new(
        proc_macro2::Span::call_site(),
        "#[interface(id = ...)] attribute is required",
    ))
}

/// Parsed interface attribute.
struct InterfaceAttr {
    id: u64,
}

impl syn::parse::Parse for InterfaceAttr {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let ident: Ident = input.parse()?;
        if ident != "id" {
            return Err(syn::Error::new_spanned(
                ident,
                "expected `id` in interface attribute",
            ));
        }
        let _eq: syn::Token![=] = input.parse()?;
        let value: Expr = input.parse()?;

        // Extract the numeric value
        let id = match &value {
            Expr::Lit(ExprLit {
                lit: Lit::Int(lit_int),
                ..
            }) => lit_int.base10_parse::<u64>()?,
            _ => {
                return Err(syn::Error::new_spanned(
                    value,
                    "expected integer literal for interface id",
                ));
            }
        };

        Ok(InterfaceAttr { id })
    }
}

/// Parse tuple type `(RequestType, ResponseType)` and extract the request type.
fn parse_tuple_request_type(ty: &Type) -> syn::Result<Type> {
    match ty {
        Type::Tuple(tuple) => {
            if tuple.elems.len() != 2 {
                return Err(syn::Error::new_spanned(
                    ty,
                    "expected tuple (RequestType, ResponseType)",
                ));
            }
            Ok(tuple.elems.first().cloned().unwrap())
        }
        Type::Path(path) => {
            // Handle case where it might be a type alias or fully qualified path
            // Try to get generic arguments if it's something like Tuple<A, B>
            if let Some(segment) = path.path.segments.last()
                && let PathArguments::AngleBracketed(args) = &segment.arguments
                && !args.args.is_empty()
                && let Some(GenericArgument::Type(first)) = args.args.first()
            {
                return Ok(first.clone());
            }
            Err(syn::Error::new_spanned(
                ty,
                "expected tuple (RequestType, ResponseType)",
            ))
        }
        _ => Err(syn::Error::new_spanned(
            ty,
            "expected tuple (RequestType, ResponseType)",
        )),
    }
}
