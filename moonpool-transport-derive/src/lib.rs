//! Proc-macro for FDB-style Interface pattern.
//!
//! This crate provides the `#[interface]` attribute macro that generates
//! `{Name}Server` and `{Name}Client` structs from a trait definition.
//!
//! # Example
//!
//! ```rust,ignore
//! use moonpool_transport::interface;
//!
//! #[interface(id = 0xCA1C_0000)]
//! trait Calculator {
//!     async fn add(&self, req: AddRequest) -> AddResponse;
//!     async fn sub(&self, req: SubRequest) -> SubResponse;
//! }
//! ```
//!
//! This generates:
//! - `CalculatorServer<C>` with `RequestStream` fields and `init()` method
//! - `CalculatorClient` with method accessors returning `Endpoint`
//! - The trait itself with `#[async_trait(?Send)]`

use proc_macro::TokenStream;
use quote::{format_ident, quote};
use syn::{Expr, ExprLit, FnArg, Ident, ItemTrait, Lit, TraitItem, parse_macro_input};

/// Attribute macro for FDB-style Interface pattern.
///
/// Generates `{Name}Server` and `{Name}Client` structs from the trait definition.
///
/// # Attributes
///
/// - `#[interface(id = 0x...)]` - Required. Sets the interface ID (u64).
///
/// # Methods
///
/// Each method must be async with signature `async fn name(&self, req: ReqType) -> RespType`.
/// Method indices are derived from method declaration order.
#[proc_macro_attribute]
pub fn interface(attr: TokenStream, item: TokenStream) -> TokenStream {
    let attr = parse_macro_input!(attr as InterfaceAttr);
    let item = parse_macro_input!(item as ItemTrait);

    match interface_impl(attr, item) {
        Ok(tokens) => tokens.into(),
        Err(err) => err.to_compile_error().into(),
    }
}

/// Method info extracted from trait methods.
struct MethodInfo {
    index: u32,
    name: Ident,
    req_type: syn::Type,
}

fn interface_impl(attr: InterfaceAttr, item: ItemTrait) -> syn::Result<proc_macro2::TokenStream> {
    let interface_id = attr.id;
    let name = &item.ident;
    let server_name = format_ident!("{}Server", name);
    let client_name = format_ident!("{}Client", name);

    // Parse trait methods
    let mut method_infos: Vec<MethodInfo> = Vec::new();
    for (index, trait_item) in item.items.iter().enumerate() {
        if let TraitItem::Fn(method) = trait_item {
            let method_name = &method.sig.ident;

            // Extract request type from method signature: async fn name(&self, req: ReqType) -> RespType
            let req_type = extract_request_type(&method.sig)?;

            method_infos.push(MethodInfo {
                index: index as u32,
                name: method_name.clone(),
                req_type,
            });
        }
    }

    let method_count = method_infos.len() as u32;

    // Generate server fields
    let server_fields = method_infos.iter().map(|m| {
        let name = &m.name;
        let req_type = &m.req_type;
        quote! { pub #name: moonpool_transport::RequestStream<#req_type, C> }
    });

    // Generate server init - clone codec for all but the last field
    let server_inits: Vec<_> = method_infos
        .iter()
        .enumerate()
        .map(|(i, m)| {
            let name = &m.name;
            let idx = m.index;
            let is_last = i == method_infos.len() - 1;
            if is_last {
                quote! {
                    let (#name, _) = transport.register_handler_at(Self::INTERFACE_ID, #idx as u64, codec);
                }
            } else {
                quote! {
                    let (#name, _) = transport.register_handler_at(Self::INTERFACE_ID, #idx as u64, codec.clone());
                }
            }
        })
        .collect();

    let server_field_names: Vec<_> = method_infos.iter().map(|m| &m.name).collect();

    // Generate client methods
    let client_methods = method_infos.iter().map(|m| {
        let name = &m.name;
        let idx = m.index;
        quote! {
            /// Get endpoint for this method.
            pub fn #name(&self) -> moonpool_transport::Endpoint {
                moonpool_transport::Endpoint::new(
                    self.base.address.clone(),
                    moonpool_transport::UID::new(Self::INTERFACE_ID, #idx as u64)
                )
            }
        }
    });

    // Generate the trait with async_trait attribute
    let trait_vis = &item.vis;
    let trait_items = &item.items;

    let expanded = quote! {
        // Emit the original trait with async_trait(?Send)
        #[async_trait::async_trait(?Send)]
        #trait_vis trait #name {
            #(#trait_items)*
        }

        /// Server-side interface with RequestStreams.
        ///
        /// Generated by `#[interface]`.
        pub struct #server_name<C: moonpool_transport::MessageCodec> {
            #(#server_fields,)*
        }

        impl<C: moonpool_transport::MessageCodec + Clone> #server_name<C> {
            /// Interface identifier.
            pub const INTERFACE_ID: u64 = #interface_id;

            /// Number of methods in this interface.
            pub const METHOD_COUNT: u32 = #method_count;

            /// Initialize the server interface, registering all handlers.
            pub fn init<N, T, TP>(transport: &std::rc::Rc<moonpool_transport::NetTransport<N, T, TP>>, codec: C) -> Self
            where
                N: moonpool_transport::NetworkProvider + Clone + 'static,
                T: moonpool_transport::TimeProvider + Clone + 'static,
                TP: moonpool_transport::TaskProvider + Clone + 'static,
            {
                #(#server_inits)*
                Self { #(#server_field_names,)* }
            }
        }

        /// Client-side interface with Endpoints.
        ///
        /// Generated by `#[interface]`.
        /// Only the base endpoint is serialized; method endpoints are derived.
        #[derive(Clone)]
        pub struct #client_name {
            base: moonpool_transport::Endpoint,
        }

        impl #client_name {
            /// Interface identifier.
            pub const INTERFACE_ID: u64 = #interface_id;

            /// Number of methods in this interface.
            pub const METHOD_COUNT: u32 = #method_count;

            /// Create a new client interface from a network address.
            pub fn new(address: moonpool_transport::NetworkAddress) -> Self {
                Self {
                    base: moonpool_transport::Endpoint::new(address, moonpool_transport::UID::new(Self::INTERFACE_ID, 0)),
                }
            }

            /// Create a client interface from an existing endpoint.
            pub fn from_endpoint(base: moonpool_transport::Endpoint) -> Self {
                Self { base }
            }

            /// Get the base endpoint (method 0).
            pub fn base_endpoint(&self) -> &moonpool_transport::Endpoint {
                &self.base
            }

            #(#client_methods)*
        }

        impl serde::Serialize for #client_name {
            fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
                self.base.serialize(serializer)
            }
        }

        impl<'de> serde::Deserialize<'de> for #client_name {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                let base = moonpool_transport::Endpoint::deserialize(deserializer)?;
                Ok(Self { base })
            }
        }
    };

    Ok(expanded)
}

/// Extract request type from method signature: async fn name(&self, req: ReqType) -> RespType
fn extract_request_type(sig: &syn::Signature) -> syn::Result<syn::Type> {
    // Skip &self, get the second argument
    let mut inputs = sig.inputs.iter();

    // First should be &self
    match inputs.next() {
        Some(FnArg::Receiver(_)) => {}
        _ => {
            return Err(syn::Error::new_spanned(
                sig,
                "Interface method must have &self as first parameter",
            ));
        }
    }

    // Second should be the request parameter
    match inputs.next() {
        Some(FnArg::Typed(pat_type)) => Ok((*pat_type.ty).clone()),
        _ => Err(syn::Error::new_spanned(
            sig,
            "Interface method must have a request parameter: async fn name(&self, req: ReqType) -> RespType",
        )),
    }
}

/// Parsed interface attribute.
struct InterfaceAttr {
    id: u64,
}

impl syn::parse::Parse for InterfaceAttr {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let ident: Ident = input.parse()?;
        if ident != "id" {
            return Err(syn::Error::new_spanned(
                ident,
                "expected `id` in interface attribute",
            ));
        }
        let _eq: syn::Token![=] = input.parse()?;
        let value: Expr = input.parse()?;

        // Extract the numeric value
        let id = match &value {
            Expr::Lit(ExprLit {
                lit: Lit::Int(lit_int),
                ..
            }) => lit_int.base10_parse::<u64>()?,
            _ => {
                return Err(syn::Error::new_spanned(
                    value,
                    "expected integer literal for interface id",
                ));
            }
        };

        Ok(InterfaceAttr { id })
    }
}
