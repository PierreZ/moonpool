//! FDB-style service pattern support.
//!
//! This module provides helpers for working with services generated by the
//! `#[service]` macro (from `moonpool-transport-derive`).
//!
//! # Overview
//!
//! The `#[service(id = ...)]` macro generates all RPC boilerplate from a trait:
//!
//! - **`&self` methods** (RPC mode): `{Name}Server<C>`, `{Name}Client`, `Bound{Name}Client<P, C>`
//! - **`&mut self` methods** (Actor mode): `{Name}Ref<P>`, `dispatch_{name}()`, `{name}_methods` module
//!
//! # Example
//!
//! ```rust,ignore
//! #[service(id = 0xCA1C_0000)]
//! trait Calculator {
//!     async fn add(&self, req: AddRequest) -> Result<AddResponse, RpcError>;
//!     async fn sub(&self, req: SubRequest) -> Result<SubResponse, RpcError>;
//! }
//!
//! // Server
//! let calc = CalculatorServer::init(&transport, JsonCodec);
//!
//! // Client
//! let client = CalculatorClient::new(server_addr).bind(&transport, JsonCodec);
//! let resp = client.add(request).await?;
//! ```
//!
//! # Serialization
//!
//! Client interfaces serialize only the base endpoint. Method endpoints
//! are derived using `Endpoint::adjusted()`, following FoundationDB's pattern.

use crate::{Endpoint, UID};

/// Generate method endpoint from base endpoint and index.
///
/// Uses FDB's adjustment pattern via `Endpoint::adjusted()`.
///
/// Note: Method indices start at 1 (index 0 is reserved for virtual actor dispatch).
///
/// # Example
///
/// ```rust,ignore
/// let base = Endpoint::new(addr, UID::new(0xCA1C, 0));
/// let add_endpoint = method_endpoint(&base, 1);  // first method
/// let sub_endpoint = method_endpoint(&base, 2);  // second method
/// ```
pub fn method_endpoint(base: &Endpoint, method_index: u32) -> Endpoint {
    base.adjusted(method_index)
}

/// Generate UID for a specific interface method.
///
/// Note: Method indices start at 1 (index 0 is reserved for virtual actor dispatch).
///
/// # Example
///
/// ```rust,ignore
/// let add_uid = method_uid(0xCA1C_0000, 1);  // first method
/// let sub_uid = method_uid(0xCA1C_0000, 2);  // second method
/// ```
pub const fn method_uid(interface_id: u64, method_index: u32) -> UID {
    UID::new(interface_id, method_index as u64)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::NetworkAddress;
    use std::net::{IpAddr, Ipv4Addr};

    #[test]
    fn test_method_endpoint() {
        let addr = NetworkAddress::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 4500);
        let base = Endpoint::new(addr, UID::new(0xCA1C_0000, 0));

        let e0 = method_endpoint(&base, 0);
        let e1 = method_endpoint(&base, 1);
        let e2 = method_endpoint(&base, 2);

        // All should have same address
        assert_eq!(base.address, e0.address);
        assert_eq!(base.address, e1.address);
        assert_eq!(base.address, e2.address);

        // Tokens should be different
        assert_ne!(e0.token, e1.token);
        assert_ne!(e1.token, e2.token);
        assert_ne!(e0.token, e2.token);

        // Method 0 should match base
        assert_eq!(base.token, e0.token);
    }

    #[test]
    fn test_method_uid() {
        let interface_id = 0xCA1C_0000_u64;

        let uid0 = method_uid(interface_id, 0);
        let uid1 = method_uid(interface_id, 1);
        let uid2 = method_uid(interface_id, 2);

        assert_eq!(uid0, UID::new(interface_id, 0));
        assert_eq!(uid1, UID::new(interface_id, 1));
        assert_eq!(uid2, UID::new(interface_id, 2));

        // All unique
        assert_ne!(uid0, uid1);
        assert_ne!(uid1, uid2);
    }
}
