//! FDB-style Interface pattern support.
//!
//! This module provides traits and helpers for working with interfaces
//! generated by `#[derive(Interface)]`.
//!
//! # Overview
//!
//! The Interface pattern bundles multiple RPC methods into a single unit:
//!
//! - **Server-side**: `{Name}Server<C>` struct with `RequestStream` fields
//! - **Client-side**: `{Name}Client` struct with method accessors
//!
//! # Example
//!
//! ```rust,ignore
//! use moonpool_transport::Interface;
//!
//! #[derive(Interface)]
//! #[interface(id = 0xCA1C_0000)]
//! struct Calculator {
//!     add: (AddRequest, AddResponse),
//!     sub: (SubRequest, SubResponse),
//! }
//!
//! // Server
//! let calc = CalculatorServer::init(&transport, JsonCodec);
//!
//! // Client
//! let calc = CalculatorClient::new(server_addr);
//! send_request(&transport, &calc.add(), request, JsonCodec)?;
//! ```
//!
//! # Serialization
//!
//! Client interfaces serialize only the base endpoint. Method endpoints
//! are derived using `Endpoint::adjusted()`, following FoundationDB's pattern.

use crate::{Endpoint, UID};

/// Generate method endpoint from base endpoint and index.
///
/// Uses FDB's adjustment pattern via `Endpoint::adjusted()`.
///
/// # Example
///
/// ```rust,ignore
/// let base = Endpoint::new(addr, UID::new(0xCA1C, 0));
/// let add_endpoint = method_endpoint(&base, 0);
/// let sub_endpoint = method_endpoint(&base, 1);
/// ```
pub fn method_endpoint(base: &Endpoint, method_index: u32) -> Endpoint {
    base.adjusted(method_index)
}

/// Generate UID for a specific interface method.
///
/// # Example
///
/// ```rust,ignore
/// let add_uid = method_uid(0xCA1C_0000, 0);
/// let sub_uid = method_uid(0xCA1C_0000, 1);
/// ```
pub const fn method_uid(interface_id: u64, method_index: u32) -> UID {
    UID::new(interface_id, method_index as u64)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::NetworkAddress;
    use std::net::{IpAddr, Ipv4Addr};

    #[test]
    fn test_method_endpoint() {
        let addr = NetworkAddress::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 4500);
        let base = Endpoint::new(addr, UID::new(0xCA1C_0000, 0));

        let e0 = method_endpoint(&base, 0);
        let e1 = method_endpoint(&base, 1);
        let e2 = method_endpoint(&base, 2);

        // All should have same address
        assert_eq!(base.address, e0.address);
        assert_eq!(base.address, e1.address);
        assert_eq!(base.address, e2.address);

        // Tokens should be different
        assert_ne!(e0.token, e1.token);
        assert_ne!(e1.token, e2.token);
        assert_ne!(e0.token, e2.token);

        // Method 0 should match base
        assert_eq!(base.token, e0.token);
    }

    #[test]
    fn test_method_uid() {
        let interface_id = 0xCA1C_0000_u64;

        let uid0 = method_uid(interface_id, 0);
        let uid1 = method_uid(interface_id, 1);
        let uid2 = method_uid(interface_id, 2);

        assert_eq!(uid0, UID::new(interface_id, 0));
        assert_eq!(uid1, UID::new(interface_id, 1));
        assert_eq!(uid2, UID::new(interface_id, 2));

        // All unique
        assert_ne!(uid0, uid1);
        assert_ne!(uid1, uid2);
    }
}
