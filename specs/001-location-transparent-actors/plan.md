# Implementation Plan: Location-Transparent Distributed Actor System

**Branch**: `001-location-transparent-actors` | **Date**: 2025-10-22 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-location-transparent-actors/spec.md`

**Note**: This plan was generated by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Build a location-transparent distributed actor system where developers obtain actor references by ID without knowing physical node location. The system automatically activates actors on-demand, routes messages across nodes via a distributed directory, processes messages one-at-a-time per actor with single-threaded guarantees, and handles timeouts with request-response correlation. Actors can optionally persist typed state via ActorState<T> wrapper (loaded on activation as Option<Self::State>, explicit persist() during processing). Framework manages serialization via StateSerializer trait (JSON default). Focus on core distributed pattern without advanced features (transactions, migration, reentrancy), demonstrating that BankAccount actors work reliably across node boundaries under hostile testing conditions.

## Technical Context

**Language/Version**: Rust 1.75+ (stable)
**Primary Dependencies**:
- `moonpool-foundation` (deterministic simulation framework, PeerTransport, Buggify)
- `tokio` (async runtime, single-threaded via `new_current_thread().build_local()`)
- `serde` + `serde_json` (message serialization)
- `async-trait` (trait async methods with `?Send`)

**Storage**:
- **Typed state wrapper**: `ActorState<T>` wrapper manages persistence with automatic serialization
- **Actor-facing API**: Actors receive `Option<Self::State>` in on_activate(), call `persist()` to save
- **Framework-managed serialization**: `StateSerializer` trait (JSON default) handles type conversion
- **Low-level provider**: `StorageProvider` trait operates on Vec<u8>, pluggable implementations
- **No concurrency control**: Relies on single-activation guarantee per actor
- **Data isolation**: Keys include namespace/actor_type::key for natural partitioning
- **Explicit operations**: No automatic persistence, actors call persist() explicitly
- **Result-based errors**: All operations return Result for explicit error handling

**Testing**:
- `cargo nextest` (test runner)
- Deterministic simulation with `SimulationBuilder` from foundation
- Buggify chaos testing (0.5/0.25 activation/firing probabilities)
- Multi-topology tests (1x1, 2x2, 10x10 node clusters)
- 100% `sometimes_assert!` coverage requirement

**Target Platform**: Linux server (single-core execution model, no Send/Sync requirements)

**Project Type**: Single workspace crate (`moonpool/`) building on `moonpool-foundation/`

**Performance Goals**:
- Reference retrieval: <100ms (P95)
- Message routing: 100% delivery in static cluster
- Actor activation: <500ms (P95) including storage load
- Storage operations: <50ms (P95) for naive implementation
- Request-response correlation: 100% accuracy under 1000+ concurrent requests

**Constraints**:
- Single-threaded execution (no Send/Sync, `#[async_trait(?Send)]`)
- Static cluster topology (no dynamic membership)
- No network partition handling in this phase
- Storage operations synchronous from actor perspective (async internally)
- Maximum message size: 1MB (configurable)
- Actor idle timeout: 10 minutes (configurable)

**Scale/Scope**:
- Support 100+ actors per node
- Support 10+ node clusters
- Handle 1000+ messages/second per node
- Storage keys: <256 characters
- State size: <10MB per actor (in-memory constraint)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Principle I: Determinism Over Convenience
✅ **PASS** - All async operations use provider abstractions (TimeProvider, NetworkProvider, TaskProvider, StorageProvider)
- Network: PeerTransport with injected NetworkProvider
- Time: Injected TimeProvider for sleep/timeout
- Tasks: TaskProvider for spawn_task
- Storage: StorageProvider trait for pluggable backends (simulation vs production)

### Principle II: Explicitness Over Implicitness
✅ **PASS** - All error handling explicit via Result types
- MessageBus operations return Result<T, MessageError>
- Actor methods return Result<T, ActorError>
- Storage operations return Result<T, StorageError>
- Directory operations return Result<T, DirectoryError>
- No unwrap() or expect() in production code

### Principle III: Single-Core Simplicity
✅ **PASS** - No Send/Sync requirements
- All traits use `#[async_trait(?Send)]`
- Runtime: `Builder::new_current_thread().build_local()`
- Interior mutability via RefCell (not Mutex)
- Correlation IDs use Cell (not AtomicU64)
- Storage access single-threaded (no concurrency control needed)

### Principle IV: Trait-Based Design
✅ **PASS** - Depend on traits, not concrete types
- Directory: trait with SimpleDirectory implementation
- StorageProvider: trait with pluggable implementations
- NetworkProvider, TimeProvider, TaskProvider: from foundation
- MessageBus generic over provider traits
- Actor: trait implemented by user code

### Principle V: State Machine Clarity
✅ **PASS** - Explicit enum-based state machines
- ActivationState: Creating → Activating → Valid → Deactivating → Invalid
- Direction: Request → Response, OneWay (terminal)
- PlacementDecision: enum for directory placement outcomes
- Guarded state transitions with can_transition_to() validation

### Principle VI: Comprehensive Chaos Testing
✅ **PASS** - All features tested under hostile simulation
- Buggify injection points in activation, directory, message routing, storage
- Multi-topology tests (1x1, 2x2, 10x10)
- Target: 100% `sometimes_assert!` coverage
- Storage failure injection via Buggify
- Invariants: banking invariant, message delivery, no duplicate activations

### Principle VII: Simplicity First (KISS)
✅ **PASS** - Simple, direct implementation
- Naive storage: load/save only (no transactions, versioning, optimistic locking)
- Directory: eventual consistency (no strong consistency complexity)
- No automatic persistence (explicit save calls only)
- Static cluster topology (no dynamic membership protocol)
- Unbounded message queues (no backpressure complexity)

## Project Structure

### Documentation (this feature)

```
specs/[###-feature]/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output (/speckit.plan command)
├── data-model.md        # Phase 1 output (/speckit.plan command)
├── quickstart.md        # Phase 1 output (/speckit.plan command)
├── contracts/           # Phase 1 output (/speckit.plan command)
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)

```
moonpool/
├── src/
│   ├── actor/
│   │   ├── id.rs              # ActorId, NodeId, CorrelationId
│   │   ├── lifecycle.rs       # ActivationState enum
│   │   ├── context.rs         # ActorContext<A>
│   │   ├── catalog.rs         # ActorCatalog (double-check locking)
│   │   ├── traits.rs          # Actor trait (with State associated type)
│   │   ├── state.rs           # ActorState<T> wrapper
│   │   └── mod.rs
│   ├── messaging/
│   │   ├── message.rs         # Message, Direction, MessageFlags
│   │   ├── address.rs         # ActorAddress
│   │   ├── bus.rs             # MessageBus (routing + correlation)
│   │   ├── correlation.rs     # CallbackData
│   │   ├── envelope.rs        # ActorEnvelope (wire format)
│   │   └── mod.rs
│   ├── directory/
│   │   ├── traits.rs          # Directory trait
│   │   ├── simple.rs          # SimpleDirectory (eventual consistency)
│   │   ├── placement.rs       # PlacementDecision, two-random-choices
│   │   └── mod.rs
│   ├── storage/
│   │   ├── traits.rs          # StorageProvider trait (Vec<u8> operations)
│   │   ├── serializer.rs      # StateSerializer trait (JSON default)
│   │   ├── memory.rs          # InMemoryStorage (testing)
│   │   ├── error.rs           # StorageError types
│   │   └── mod.rs
│   ├── runtime/
│   │   ├── actor_runtime.rs   # ActorRuntime (entry point)
│   │   ├── config.rs          # RuntimeConfig
│   │   └── mod.rs
│   ├── error.rs               # ActorError, MessageError, etc.
│   ├── prelude.rs             # Common imports
│   └── lib.rs
│
└── tests/
    ├── simulation/
    │   ├── bank_account/
    │   │   ├── actor.rs       # BankAccountActor impl
    │   │   ├── workload.rs    # Simulation workload
    │   │   └── tests.rs       # Multi-topology tests
    │   └── common/
    │       └── metrics.rs     # Banking invariant
    ├── integration/
    │   ├── single_node.rs     # Single-node cluster tests
    │   ├── multi_node.rs      # Multi-node cluster tests
    │   └── persistence.rs     # Storage integration tests
    └── unit/
        ├── actor/
        │   └── lifecycle_test.rs
        ├── messaging/
        │   └── correlation_test.rs
        ├── directory/
        │   └── placement_test.rs
        └── storage/
            └── memory_test.rs
```

**Structure Decision**: Single project structure (Option 1). This is a library crate building on moonpool-foundation. Actor system is self-contained with clear module boundaries: actor (lifecycle), messaging (routing), directory (location), storage (persistence), and runtime (bootstrap).

## Complexity Tracking

*Fill ONLY if Constitution Check has violations that must be justified*

**No violations** - All constitution principles satisfied.

